<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS460 Final Project - Prosthetic Biomechanics Simulator</title>
<link rel="icon" href="data:,">

<style>
  html, body { margin:0; background:#000; overflow:hidden; height:100%; }
  canvas { display:block; }
</style>

<!-- FPS Stats -->
<script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>

<!-- Importmap -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>
</head>

<body>
<script type="module">

// -------------------------------------------------------------
// IMPORTS
// -------------------------------------------------------------
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

// -------------------------------------------------------------
// SCENE SETUP
// -------------------------------------------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
camera.position.set(0, 6, 20);
camera.lookAt(0, 5, 0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// soft lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));

const dir = new THREE.DirectionalLight(0xffffff, 1.4);
dir.position.set(15, 20, 10);
dir.castShadow = true;
scene.add(dir);

// Grid (kept, because it adds spatial cues and professionalism)
const grid = new THREE.GridHelper(40, 80, 0x333333, 0x222222);
scene.add(grid);

// FPS
const stats = new Stats();
document.body.appendChild(stats.dom);

// -------------------------------------------------------------
// UI CONTROLS
// -------------------------------------------------------------
const pane = new Pane({ title:"Biomechanical Controls" });

const params = {
  angle: 0,
  load: 1.0,
  tightness: 1.0,
  socket_opacity: 0.4,
  wireframe: false,
  autoGait: false
};

pane.addBinding(params, "angle",       { min:-45, max:90, label:"Joint Angle" });
pane.addBinding(params, "load",        { min:0, max:3, label:"Load Factor" });
pane.addBinding(params, "tightness",   { min:0.5, max:2, label:"Socket Tightness" });
pane.addBinding(params, "socket_opacity", { min:0.1, max:1, label:"Socket Opacity" });
pane.addBinding(params, "wireframe",   { label:"Wireframe Mode" });
pane.addBinding(params, "autoGait",    { label:"Simulate Gait Cycle" });

pane.addButton({ title:"Front View" }).on("click", ()=>{
  camera.position.set(0, 6, 20);
  camera.lookAt(0,5,0);
});
pane.addButton({ title:"Side View" }).on("click", ()=>{
  camera.position.set(20, 6, 0);
  camera.lookAt(6,5,0);
});

// -------------------------------------------------------------
// PRESSURE STATS PANEL
// -------------------------------------------------------------
const pressureStats = { max:0, min:0, avg:0 };
const pFolder = pane.addFolder({ title:"Pressure Stats" });
pFolder.addBinding(pressureStats, "max", { readonly:true });
pFolder.addBinding(pressureStats, "min", { readonly:true });
pFolder.addBinding(pressureStats, "avg", { readonly:true });

// -------------------------------------------------------------
// HEATMAP LEGEND (kept for presentation clarity)
// -------------------------------------------------------------
function addHeatmapLegend() {
  const c=document.createElement("canvas");
  c.width=40; c.height=256;
  const ctx=c.getContext("2d");

  for (let i=0;i<256;i++){
    const p=i/256;
    const col=new THREE.Color();
    col.setHSL((1-p)*0.7,1,0.5);
    ctx.fillStyle=`rgb(${col.r*255},${col.g*255},${col.b*255})`;
    ctx.fillRect(0,255-i,40,1);
  }

  const tex=new THREE.CanvasTexture(c);
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map:tex }));
  spr.scale.set(1,4,1);
  spr.position.set(11, 7, 0);
  scene.add(spr);

  // Title
  const labelCanvas = document.createElement("canvas");
  labelCanvas.width = 300; labelCanvas.height = 80;
  const ctx2 = labelCanvas.getContext("2d");
  ctx2.font = "40px Arial"; ctx2.fillStyle = "white";
  ctx2.fillText("Pressure", 20, 55);
  const tex2 = new THREE.CanvasTexture(labelCanvas);
  const labelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex2 }));
  labelSprite.scale.set(3,1,1);
  labelSprite.position.set(11, 9.5, 0);
  scene.add(labelSprite);
}
addHeatmapLegend();

// -------------------------------------------------------------
// LOAD PROSTHETIC MODEL
// -------------------------------------------------------------
let prosthetic=null;
let prostheticAttached=false;

new GLTFLoader().load(
  "https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb",
  gltf=>{
    prosthetic=gltf.scene;
    prosthetic.scale.set(1.6,1.6,1.6);
    prosthetic.rotation.set(0,0,0);
    scene.add(prosthetic);
  }
);

// -------------------------------------------------------------
// LIMB SYSTEM
// -------------------------------------------------------------
const limbGroup=new THREE.Group();
limbGroup.position.set(6,5,0);
scene.add(limbGroup);

const upper=new THREE.Mesh(
  new THREE.CylinderGeometry(0.4,0.4,2,32),
  new THREE.MeshStandardMaterial({ color:0x66aaff })
);
upper.position.y=1;
limbGroup.add(upper);

const joint=new THREE.Group();
joint.position.y=0;
upper.add(joint);

const lower=new THREE.Mesh(
  new THREE.CylinderGeometry(0.35,0.35,2,32),
  new THREE.MeshStandardMaterial({ color:0x4477dd })
);
lower.position.y=-2;
joint.add(lower);

// Attach prosthetic 
function tryAttachProsthetic(){
  if (!prosthetic || prostheticAttached) return;
  prostheticAttached=true;

  joint.add(prosthetic);
  prosthetic.position.set(0,-1.2,0);
}

// -------------------------------------------------------------
// SOCKET
// -------------------------------------------------------------
const socket=new THREE.Mesh(
  new THREE.CylinderGeometry(0.55,0.65,2.4,64,1,true),
  new THREE.MeshStandardMaterial({
    color:0xffffff,
    transparent:true,
    opacity:params.socket_opacity,
    vertexColors:true,
    side:THREE.DoubleSide,
    depthWrite:false,
    blending:THREE.NormalBlending
  })
);
socket.position.set(6,5,0);
scene.add(socket);

// -------------------------------------------------------------
// HEATMAP (final improved version)
// -------------------------------------------------------------
function updateHeatmap(mesh, load, angle, tightness){
  const pos=mesh.geometry.attributes.position;
  const count=pos.count;
  const colors=mesh.geometry.attributes.color?.array || new Float32Array(count*3);

  let maxP=0, minP=999, total=0;
  const bendFactor=Math.abs(angle)/90;

  for(let i=0;i<count;i++){
    const x=pos.getX(i);
    const y=pos.getY(i);
    const z=pos.getZ(i);

    const radial=Math.sqrt(x*x + z*z);
    const angular=Math.abs(Math.atan2(z,x));

    let pressure =
       Math.pow(Math.abs(y)*load, tightness) +
       radial * 0.4 +
       angular * 0.15 +
       bendFactor * 0.4;

    pressure = pressure / 3.0;
    pressure = THREE.MathUtils.clamp(pressure, 0, 1);

    maxP=Math.max(maxP,pressure);
    minP=Math.min(minP,pressure);
    total+=pressure;

    const c=new THREE.Color();
    c.setHSL((1-pressure)*0.7,1,0.5);

    colors[i*3]=c.r;
    colors[i*3+1]=c.g;
    colors[i*3+2]=c.b;
  }

  pressureStats.max=maxP.toFixed(2);
  pressureStats.min=minP.toFixed(2);
  pressureStats.avg=(total/count).toFixed(2);

  mesh.geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));
  mesh.geometry.attributes.color.needsUpdate=true;
}

// -------------------------------------------------------------
// ANIMATION LOOP
// -------------------------------------------------------------
function animate(){
  stats.begin();
  requestAnimationFrame(animate);

  tryAttachProsthetic();

  if(params.autoGait){
    params.angle = Math.sin(Date.now()*0.001)*45;
  }

  // joint motion
  joint.rotation.x=THREE.MathUtils.degToRad(params.angle);

  // limb compression
  const contraction = 1 - params.load * 0.05;
  upper.scale.y = contraction;
  lower.scale.y = contraction;

  // socket tightness
  socket.scale.set(params.tightness, 1, params.tightness);

  socket.material.opacity=params.socket_opacity;
  socket.material.wireframe=params.wireframe;

  updateHeatmap(socket, params.load, params.angle, params.tightness);

  renderer.render(scene,camera);
  controls.update();
  stats.end();
}
animate();

// -------------------------------------------------------------
// RESIZE HANDLER
// -------------------------------------------------------------
window.addEventListener("resize", ()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

</script>
</body>
</html>
